# 01 데이터 모델의 이해
## 모델링의 특징
1️⃣ 추상화: 현실 세계 데이터를 논리적 개념으로 변환함. (예: "고객" → 엔터티, "주문" → 관계)
2️⃣ 단순화: 불필요한 데이터 제거, 핵심 요소만 유지함. (예: 불필요한 속성 제외)
3️⃣ 명확화: 데이터 구조와 관계를 명확히 정의함. (예: 정규화, 제약 조건 설정)
4️⃣ 정확성(정밀화): 데이터 무결성, 일관성 유지. (예: 기본키 설정, 참조 무결성 적용)

## 모델링의 3가지 관점
1️⃣ 데이터 관점 (정적 관점)
데이터 구조와 관계를 정의함.
주요 개념: 엔터티, 속성, 관계, 정규화
사용 기법: ERD (개체-관계 다이어그램)
2️⃣ 프로세스 관점 (동적 관점)
데이터가 어떻게 흐르고 처리되는지를 정의함.
주요 개념: 입력, 출력, 프로세스, 저장소
사용 기법: DFD (데이터 흐름도)
3️⃣ 데이터와 프로세스의 상관 관점 (관계 중심)
데이터와 프로세스 간의 관계를 정의함.
주요 개념: CRUD 매트릭스(데이터 조작 연산), 릴레이션과 트랜잭션 관계
사용 기법: CRUD 매트릭스, 정규화 분석

요점:
데이터 관점 → 구조 중심 (ERD)
프로세스 관점 → 흐름 중심 (DFD)
데이터-프로세스 상관 관점 → 관계 중심 (CRUD 매트릭스)

## 데이터 품질 보장을 위해 유의해야 할 점
1️⃣ 중복 방지
동일한 데이터가 여러 위치에 저장되지 않도록 정규화 적용.
키(Key) 설정을 통해 중복을 최소화함.
2️⃣ 유연한 설계 (비유연성 해결)
변경이 용이하도록 확장성을 고려한 데이터 모델링.
제약 조건을 과도하게 두지 않고, 필요 시 확장이 가능하게 설계.
3️⃣ 일관성 유지 (비일관성 해결)
데이터 무결성(참조 무결성, 도메인 무결성 등) 보장.
트랜잭션을 통한 일관된 데이터 처리.
📌 요약:
✔ 중복 방지 → 정규화, 키 설정
✔ 유연한 설계 → 확장 가능하게 모델링
✔ 일관성 유지 → 무결성 제약, 트랜잭션 활용

## 모델링의 3가지 단계
1️⃣ 개념적 데이터 모델링
가장 추상적인 단계, 핵심 개념만 정의함.
업무 중심으로 엔터티와 관계를 식별.
DBMS에 종속되지 않음.
예: ERD의 초기 설계

2️⃣ 논리적 데이터 모델링
재사용성이 가장 높음, 데이터 구조를 상세하게 정의.
엔터티, 속성, 관계, 키를 모두 표현.
정규화를 수행하여 데이터 품질을 높임.
특정 DBMS에 독립적이지만 구현을 고려함.

예: 정규화된 엔터티 정의, 관계 다이어그램

3️⃣ 물리적 데이터 모델링
실제 DB에 구현 가능한 모델, 성능 고려.
테이블, 컬럼, 인덱스, 파티셔닝, 저장 구조 설계.
특정 DBMS의 특성을 반영함.
예: MySQL/InnoDB의 인덱스 설계, 파티션 설정

📌 요점 정리
✔ 개념적 모델링 → 핵심 개념 정의 (추상적)
✔ 논리적 모델링 → 데이터 구조 상세화 (재사용성 높음)
✔ 물리적 모델링 → DBMS에 맞춰 최적화 (실제 구현 가능)

## 3단계 스키마 구조 - 데이터의 독립성
1️⃣ 외부 스키마 (External Schema)
사용자 관점, 개별 사용자 또는 응용 프로그램이 접근하는 데이터 구조.
동일한 데이터베이스라도 사용자마다 다르게 볼 수 있음.
예: View, 접근 권한에 따른 데이터 제한
2️⃣ 개념 스키마 (Conceptual Schema)
데이터 간 관계 관점, 데이터베이스 전체의 논리적 구조를 정의.
모든 엔터티, 속성, 관계 포함, DBMS에 독립적.
예: 정규화된 논리 모델, 엔터티 간 관계 정의
3️⃣ 내부 스키마 (Internal Schema)
물리적 관점, 실제 데이터가 저장되는 방식과 구조를 정의.
저장 구조, 컬럼 정의, 인덱스, 파티셔닝 등 포함.
예: B-Tree 인덱스, 테이블스페이스 설정, 파티션 분할

📌 데이터 독립성
✔ 논리적 독립성 (개념 스키마 ↔ 외부 스키마)
개념 스키마 변경(테이블 구조 변경) 시, 외부 스키마(View) 영향 없음.
✔ 물리적 독립성 (내부 스키마 ↔ 개념 스키마)
내부 스키마 변경(인덱스 추가, 저장 방식 변경) 시, 개념 스키마 영향 없음.

## ERD
![image](https://github.com/user-attachments/assets/487b75cd-46e2-4cb4-957d-63f7bd74c2fc)
- ERD 작성 순서
엔티티를 도출하고 그리기
배치
엔티티 간 관계 설정
관계명 기입
관계 참여도 기입
관계의 필수/선택 여부 기입

# 02 엔티티(Entity)
## 엔티티 용어
엔티티 (Entity) = 테이블 (Table)
엔티티는 현실 세계의 개체나 개념을 나타내며, 데이터베이스에서 이를 테이블로 표현합니다.
예를 들어, '고객'이라는 엔티티는 데이터베이스 내에서 '고객' 테이블로 변환됩니다.
인스턴스 (Instance) = 행 (Row)
인스턴스는 엔티티의 구체적인 데이터 항목을 의미하며, 데이터베이스에서는 이를 **행(Row)**으로 나타냅니다.
예를 들어, '고객' 엔티티의 인스턴스는 '고객' 테이블의 한 행이 됩니다.
속성 (Attribute) = 열 (Column)
속성은 엔티티의 특성을 나타내며, 데이터베이스에서는 이를 **열(Column)**로 표현합니다.
예를 들어, '고객' 엔티티의 속성은 '고객ID', '이름', '주소' 등의 열로 나타냅니다.

## 엔티티의 특징
업무에서 실제로 사용
엔티티는 현실 세계에서 의미가 있는 개체나 객체여야 하며, 실제로 업무나 시스템에서 사용되는 데이터를 대표합니다. 예를 들어, 고객, 주문, 제품 등의 엔티티는 실제로 업무에서 사용됩니다.

Unique Key가 있어야 함
엔티티는 **고유한 식별자(Unique Key)**를 가져야 합니다. 이는 해당 엔티티의 각 인스턴스를 유일하게 식별할 수 있는 속성입니다. 예를 들어, '고객ID'나 '주문ID'는 고유한 값을 가지며, 이를 통해 각 고객이나 주문을 식별할 수 있습니다.

2개 이상의 인스턴스를 갖고 있어야 함
엔티티는 최소 2개 이상의 인스턴스를 가질 수 있어야 합니다. 즉, 엔티티는 단 하나의 인스턴스만 있을 수 없으며, 여러 개의 데이터 항목(행)을 포함해야 합니다. 예를 들어, '고객' 엔티티는 여러 명의 고객을 나타낼 수 있어야 합니다. 만약 1개만 존재하거나, 앞으로도 1개만 존재할 것이라면 이는 엔티티가 아닙니다.

속성(Column)이 있어야 함
엔티티는 속성을 가지고 있어야 합니다. 속성은 엔티티의 특성이나 데이터를 나타내며, 테이블의 **열(Column)**로 표현됩니다. 예를 들어, '고객' 엔티티는 '고객ID', '이름', '주소', '전화번호' 등의 속성을 가질 수 있습니다.

다른 엔티티와 1개 이상의 관계를 갖고 있어야 함
엔티티는 다른 하나 이상의 엔티티와 관계를 가져야 합니다. 관계는 엔티티 간의 상호작용이나 연결을 나타내며, 이러한 관계는 데이터베이스 설계에서 중요한 요소입니다. 예를 들어, '고객' 엔티티는 '주문' 엔티티와 "주문한다"라는 관계를 가질 수 있습니다.

## 엔티티의 종류 - 유/무형에 따른 분류
1. 유형 엔티티 (Entity Type)
물리적 형태, 안정성, 지속성을 가진 엔티티입니다.
현실 세계에서 실제 존재하는 개체로, 물리적으로 존재하거나 지속적으로 관리되는 객체를 나타냅니다.
예:
회원: 실제로 존재하는 사람을 나타내는 엔티티입니다. 회원은 등록되고, 수정되며, 삭제될 수 있는 지속적인 존재입니다.
상품: 판매되는 상품, 재고로 관리되는 제품 등이 여기에 해당합니다. 상품은 실제로 존재하고 물리적인 형태를 가집니다.

3. 개념 엔티티 (Conceptual Entity)
물리적 형태는 없고, 개념적으로 존재하는 엔티티입니다.
물리적으로 존재하지 않지만, 특정 조직이나 시스템에서 이해하고 관리해야 할 개념을 나타냅니다.
예:
부서: 실제로 물리적으로 존재하지 않지만, 조직 내에서 중요한 개념입니다. 부서 간의 관계와 역할을 관리하는 데 사용됩니다.
학과: 대학이나 교육 기관에서 존재하는 개념으로, 학생들이 소속되는 학과를 나타냅니다.

3. 사건 엔티티 (Event Entity)
행위로 발생하는 엔티티입니다. 특정 활동이나 사건이 발생할 때 생성되는 엔티티입니다.
이 엔티티는 시간에 따라 변경되거나 종료될 수 있는 활동을 나타냅니다.
예:
주문: 고객이 제품을 주문하는 행위 자체를 나타내는 엔티티입니다. 주문은 특정 시점에 발생하며, 처리 후 종료됩니다.
이벤트 응모: 사용자가 특정 이벤트에 참여하는 행위로 생성되는 엔티티입니다. 응모는 이벤트가 종료되면 더 이상 존재하지 않을 수 있습니다.

정리
유형 엔티티는 물리적 존재와 지속적인 특성을 갖고 있습니다.
개념 엔티티는 물리적 존재는 없지만, 개념적으로 중요한 정보를 나타냅니다.
사건 엔티티는 특정 행위나 사건을 나타내며, 특정 시간에 발생하고 종료되는 특성을 가집니다.

## 엔티티의 종류 - 발생 시점에 따른 분류
1. 기본 엔티티 (Base Entity)
업무에 원래 존재하는 정보를 나타냅니다. 이 엔티티는 업무나 시스템에서 필수적인 데이터를 대표하며, 변화가 적고 안정적인 정보를 나타냅니다.
특징: 데이터가 자주 변하지 않으며, 대부분 시스템에 처음부터 존재하는 엔티티입니다.
예:
상품: 판매되는 제품에 대한 정보.
회원: 고객이나 사용자에 대한 정보.
사원: 회사에서 일하는 사람에 대한 정보.
부서: 조직 내 부서에 대한 정보.

2. 중심 엔티티 (Core Entity)
기본 엔티티로부터 파생된 엔티티로, 행위 엔티티를 생성하는 데 사용됩니다. 중심 엔티티는 기본 엔티티를 바탕으로 중요한 비즈니스 행위나 데이터를 표현하는 엔티티입니다.
특징: 특정 비즈니스 활동이나 사건을 추적하는 데 사용되며, 실제 업무 흐름과 관련된 중요한 엔티티입니다.
예:
주문: 상품이나 서비스를 구매하는 행위로 생성되는 엔티티.
매출: 상품 판매로 인해 발생하는 금전적 거래 내역.
계약: 서비스나 제품 제공을 위한 계약 정보를 나타내는 엔티티.

3. 행위 엔티티 (Action Entity)
2개 이상의 엔티티로부터 파생된 엔티티로, 특정 행위나 활동에 대한 기록을 나타냅니다. 이 엔티티는 데이터가 자주 변경되거나 증가할 수 있는 특성을 가집니다.
특징: 특정 시점에 발생한 행위나 이벤트의 내역을 기록하며, 시간이 지남에 따라 자주 갱신될 수 있습니다.

예:
주문 내역: 고객이 여러 차례 주문한 내역을 추적하는 엔티티.
이벤트 응모 이력: 사용자가 이벤트에 응모한 기록을 나타내는 엔티티.
배송 내역: 주문이 배송되는 과정에 대한 정보.
정리
기본 엔티티는 업무의 기본 정보를 나타내며 안정적입니다.
중심 엔티티는 기본 엔티티로부터 파생되어 비즈니스 활동을 추적하는 데 사용됩니다.
행위 엔티티는 2개 이상의 엔티티에서 파생되며, 자주 변경되거나 증가할 수 있는 기록을 관리합니다.

# 03 속성(Attribute)


