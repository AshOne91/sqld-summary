# 01 데이터 모델의 이해
## 모델링의 특징
1️⃣ 추상화: 현실 세계 데이터를 논리적 개념으로 변환함. (예: "고객" → 엔터티, "주문" → 관계)
2️⃣ 단순화: 불필요한 데이터 제거, 핵심 요소만 유지함. (예: 불필요한 속성 제외)
3️⃣ 명확화: 데이터 구조와 관계를 명확히 정의함. (예: 정규화, 제약 조건 설정)
4️⃣ 정확성(정밀화): 데이터 무결성, 일관성 유지. (예: 기본키 설정, 참조 무결성 적용)

## 모델링의 3가지 관점
1️⃣ 데이터 관점 (정적 관점)
데이터 구조와 관계를 정의함.
주요 개념: 엔터티, 속성, 관계, 정규화
사용 기법: ERD (개체-관계 다이어그램)
2️⃣ 프로세스 관점 (동적 관점)
데이터가 어떻게 흐르고 처리되는지를 정의함.
주요 개념: 입력, 출력, 프로세스, 저장소
사용 기법: DFD (데이터 흐름도)
3️⃣ 데이터와 프로세스의 상관 관점 (관계 중심)
데이터와 프로세스 간의 관계를 정의함.
주요 개념: CRUD 매트릭스(데이터 조작 연산), 릴레이션과 트랜잭션 관계
사용 기법: CRUD 매트릭스, 정규화 분석

요점:
데이터 관점 → 구조 중심 (ERD)
프로세스 관점 → 흐름 중심 (DFD)
데이터-프로세스 상관 관점 → 관계 중심 (CRUD 매트릭스)

## 데이터 품질 보장을 위해 유의해야 할 점
1️⃣ 중복 방지
동일한 데이터가 여러 위치에 저장되지 않도록 정규화 적용.
키(Key) 설정을 통해 중복을 최소화함.
2️⃣ 유연한 설계 (비유연성 해결)
변경이 용이하도록 확장성을 고려한 데이터 모델링.
제약 조건을 과도하게 두지 않고, 필요 시 확장이 가능하게 설계.
3️⃣ 일관성 유지 (비일관성 해결)
데이터 무결성(참조 무결성, 도메인 무결성 등) 보장.
트랜잭션을 통한 일관된 데이터 처리.
📌 요약:
✔ 중복 방지 → 정규화, 키 설정
✔ 유연한 설계 → 확장 가능하게 모델링
✔ 일관성 유지 → 무결성 제약, 트랜잭션 활용

## 모델링의 3가지 단계
1️⃣ 개념적 데이터 모델링
가장 추상적인 단계, 핵심 개념만 정의함.
업무 중심으로 엔터티와 관계를 식별.
DBMS에 종속되지 않음.
예: ERD의 초기 설계

2️⃣ 논리적 데이터 모델링
재사용성이 가장 높음, 데이터 구조를 상세하게 정의.
엔터티, 속성, 관계, 키를 모두 표현.
정규화를 수행하여 데이터 품질을 높임.
특정 DBMS에 독립적이지만 구현을 고려함.

예: 정규화된 엔터티 정의, 관계 다이어그램

3️⃣ 물리적 데이터 모델링
실제 DB에 구현 가능한 모델, 성능 고려.
테이블, 컬럼, 인덱스, 파티셔닝, 저장 구조 설계.
특정 DBMS의 특성을 반영함.
예: MySQL/InnoDB의 인덱스 설계, 파티션 설정

📌 요점 정리
✔ 개념적 모델링 → 핵심 개념 정의 (추상적)
✔ 논리적 모델링 → 데이터 구조 상세화 (재사용성 높음)
✔ 물리적 모델링 → DBMS에 맞춰 최적화 (실제 구현 가능)

## 3단계 스키마 구조 - 데이터의 독립성
1️⃣ 외부 스키마 (External Schema)
사용자 관점, 개별 사용자 또는 응용 프로그램이 접근하는 데이터 구조.
동일한 데이터베이스라도 사용자마다 다르게 볼 수 있음.
예: View, 접근 권한에 따른 데이터 제한
2️⃣ 개념 스키마 (Conceptual Schema)
데이터 간 관계 관점, 데이터베이스 전체의 논리적 구조를 정의.
모든 엔터티, 속성, 관계 포함, DBMS에 독립적.
예: 정규화된 논리 모델, 엔터티 간 관계 정의
3️⃣ 내부 스키마 (Internal Schema)
물리적 관점, 실제 데이터가 저장되는 방식과 구조를 정의.
저장 구조, 컬럼 정의, 인덱스, 파티셔닝 등 포함.
예: B-Tree 인덱스, 테이블스페이스 설정, 파티션 분할

📌 데이터 독립성
✔ 논리적 독립성 (개념 스키마 ↔ 외부 스키마)
개념 스키마 변경(테이블 구조 변경) 시, 외부 스키마(View) 영향 없음.
✔ 물리적 독립성 (내부 스키마 ↔ 개념 스키마)
내부 스키마 변경(인덱스 추가, 저장 방식 변경) 시, 개념 스키마 영향 없음.

## ERD
![image](https://github.com/user-attachments/assets/487b75cd-46e2-4cb4-957d-63f7bd74c2fc)
- ERD 작성 순서
엔티티를 도출하고 그리기
배치
엔티티 간 관계 설정
관계명 기입
관계 참여도 기입
관계의 필수/선택 여부 기입

# 02 엔티티(Entity)
## 엔티티 용어
엔티티 (Entity) = 테이블 (Table)
엔티티는 현실 세계의 개체나 개념을 나타내며, 데이터베이스에서 이를 테이블로 표현합니다.
예를 들어, '고객'이라는 엔티티는 데이터베이스 내에서 '고객' 테이블로 변환됩니다.
인스턴스 (Instance) = 행 (Row)
인스턴스는 엔티티의 구체적인 데이터 항목을 의미하며, 데이터베이스에서는 이를 **행(Row)**으로 나타냅니다.
예를 들어, '고객' 엔티티의 인스턴스는 '고객' 테이블의 한 행이 됩니다.
속성 (Attribute) = 열 (Column)
속성은 엔티티의 특성을 나타내며, 데이터베이스에서는 이를 **열(Column)**로 표현합니다.
예를 들어, '고객' 엔티티의 속성은 '고객ID', '이름', '주소' 등의 열로 나타냅니다.

## 엔티티의 특징
업무에서 실제로 사용
엔티티는 현실 세계에서 의미가 있는 개체나 객체여야 하며, 실제로 업무나 시스템에서 사용되는 데이터를 대표합니다. 예를 들어, 고객, 주문, 제품 등의 엔티티는 실제로 업무에서 사용됩니다.

Unique Key가 있어야 함
엔티티는 **고유한 식별자(Unique Key)**를 가져야 합니다. 이는 해당 엔티티의 각 인스턴스를 유일하게 식별할 수 있는 속성입니다. 예를 들어, '고객ID'나 '주문ID'는 고유한 값을 가지며, 이를 통해 각 고객이나 주문을 식별할 수 있습니다.

2개 이상의 인스턴스를 갖고 있어야 함
엔티티는 최소 2개 이상의 인스턴스를 가질 수 있어야 합니다. 즉, 엔티티는 단 하나의 인스턴스만 있을 수 없으며, 여러 개의 데이터 항목(행)을 포함해야 합니다. 예를 들어, '고객' 엔티티는 여러 명의 고객을 나타낼 수 있어야 합니다. 만약 1개만 존재하거나, 앞으로도 1개만 존재할 것이라면 이는 엔티티가 아닙니다.

속성(Column)이 있어야 함
엔티티는 속성을 가지고 있어야 합니다. 속성은 엔티티의 특성이나 데이터를 나타내며, 테이블의 **열(Column)**로 표현됩니다. 예를 들어, '고객' 엔티티는 '고객ID', '이름', '주소', '전화번호' 등의 속성을 가질 수 있습니다.

다른 엔티티와 1개 이상의 관계를 갖고 있어야 함
엔티티는 다른 하나 이상의 엔티티와 관계를 가져야 합니다. 관계는 엔티티 간의 상호작용이나 연결을 나타내며, 이러한 관계는 데이터베이스 설계에서 중요한 요소입니다. 예를 들어, '고객' 엔티티는 '주문' 엔티티와 "주문한다"라는 관계를 가질 수 있습니다.
