# 01 데이터 모델의 이해
## 모델링의 특징
1️⃣ 추상화: 현실 세계 데이터를 논리적 개념으로 변환함. (예: "고객" → 엔터티, "주문" → 관계)
2️⃣ 단순화: 불필요한 데이터 제거, 핵심 요소만 유지함. (예: 불필요한 속성 제외)
3️⃣ 명확화: 데이터 구조와 관계를 명확히 정의함. (예: 정규화, 제약 조건 설정)
4️⃣ 정확성(정밀화): 데이터 무결성, 일관성 유지. (예: 기본키 설정, 참조 무결성 적용)

## 모델링의 3가지 관점
1️⃣ 데이터 관점 (정적 관점)
데이터 구조와 관계를 정의함.
주요 개념: 엔터티, 속성, 관계, 정규화
사용 기법: ERD (개체-관계 다이어그램)
2️⃣ 프로세스 관점 (동적 관점)
데이터가 어떻게 흐르고 처리되는지를 정의함.
주요 개념: 입력, 출력, 프로세스, 저장소
사용 기법: DFD (데이터 흐름도)
3️⃣ 데이터와 프로세스의 상관 관점 (관계 중심)
데이터와 프로세스 간의 관계를 정의함.
주요 개념: CRUD 매트릭스(데이터 조작 연산), 릴레이션과 트랜잭션 관계
사용 기법: CRUD 매트릭스, 정규화 분석

요점:
데이터 관점 → 구조 중심 (ERD)
프로세스 관점 → 흐름 중심 (DFD)
데이터-프로세스 상관 관점 → 관계 중심 (CRUD 매트릭스)

## 데이터 품질 보장을 위해 유의해야 할 점
1️⃣ 중복 방지
동일한 데이터가 여러 위치에 저장되지 않도록 정규화 적용.
키(Key) 설정을 통해 중복을 최소화함.
2️⃣ 유연한 설계 (비유연성 해결)
변경이 용이하도록 확장성을 고려한 데이터 모델링.
제약 조건을 과도하게 두지 않고, 필요 시 확장이 가능하게 설계.
3️⃣ 일관성 유지 (비일관성 해결)
데이터 무결성(참조 무결성, 도메인 무결성 등) 보장.
트랜잭션을 통한 일관된 데이터 처리.
📌 요약:
✔ 중복 방지 → 정규화, 키 설정
✔ 유연한 설계 → 확장 가능하게 모델링
✔ 일관성 유지 → 무결성 제약, 트랜잭션 활용

## 모델링의 3가지 단계
1️⃣ 개념적 데이터 모델링
가장 추상적인 단계, 핵심 개념만 정의함.
업무 중심으로 엔터티와 관계를 식별.
DBMS에 종속되지 않음.
예: ERD의 초기 설계

2️⃣ 논리적 데이터 모델링
재사용성이 가장 높음, 데이터 구조를 상세하게 정의.
엔터티, 속성, 관계, 키를 모두 표현.
정규화를 수행하여 데이터 품질을 높임.
특정 DBMS에 독립적이지만 구현을 고려함.

예: 정규화된 엔터티 정의, 관계 다이어그램

3️⃣ 물리적 데이터 모델링
실제 DB에 구현 가능한 모델, 성능 고려.
테이블, 컬럼, 인덱스, 파티셔닝, 저장 구조 설계.
특정 DBMS의 특성을 반영함.
예: MySQL/InnoDB의 인덱스 설계, 파티션 설정

📌 요점 정리
✔ 개념적 모델링 → 핵심 개념 정의 (추상적)
✔ 논리적 모델링 → 데이터 구조 상세화 (재사용성 높음)
✔ 물리적 모델링 → DBMS에 맞춰 최적화 (실제 구현 가능)

## 3단계 스키마 구조 - 데이터의 독립성
1️⃣ 외부 스키마 (External Schema)
사용자 관점, 개별 사용자 또는 응용 프로그램이 접근하는 데이터 구조.
동일한 데이터베이스라도 사용자마다 다르게 볼 수 있음.
예: View, 접근 권한에 따른 데이터 제한
2️⃣ 개념 스키마 (Conceptual Schema)
데이터 간 관계 관점, 데이터베이스 전체의 논리적 구조를 정의.
모든 엔터티, 속성, 관계 포함, DBMS에 독립적.
예: 정규화된 논리 모델, 엔터티 간 관계 정의
3️⃣ 내부 스키마 (Internal Schema)
물리적 관점, 실제 데이터가 저장되는 방식과 구조를 정의.
저장 구조, 컬럼 정의, 인덱스, 파티셔닝 등 포함.
예: B-Tree 인덱스, 테이블스페이스 설정, 파티션 분할

📌 데이터 독립성
✔ 논리적 독립성 (개념 스키마 ↔ 외부 스키마)
개념 스키마 변경(테이블 구조 변경) 시, 외부 스키마(View) 영향 없음.
✔ 물리적 독립성 (내부 스키마 ↔ 개념 스키마)
내부 스키마 변경(인덱스 추가, 저장 방식 변경) 시, 개념 스키마 영향 없음.

## ERD
![image](https://github.com/user-attachments/assets/487b75cd-46e2-4cb4-957d-63f7bd74c2fc)
- ERD 작성 순서
엔티티를 도출하고 그리기
배치
엔티티 간 관계 설정
관계명 기입
관계 참여도 기입
관계의 필수/선택 여부 기입

# 02 엔티티(Entity)
## 엔티티 용어
엔티티 (Entity) = 테이블 (Table)
엔티티는 현실 세계의 개체나 개념을 나타내며, 데이터베이스에서 이를 테이블로 표현합니다.
예를 들어, '고객'이라는 엔티티는 데이터베이스 내에서 '고객' 테이블로 변환됩니다.
인스턴스 (Instance) = 행 (Row)
인스턴스는 엔티티의 구체적인 데이터 항목을 의미하며, 데이터베이스에서는 이를 **행(Row)**으로 나타냅니다.
예를 들어, '고객' 엔티티의 인스턴스는 '고객' 테이블의 한 행이 됩니다.
속성 (Attribute) = 열 (Column)
속성은 엔티티의 특성을 나타내며, 데이터베이스에서는 이를 **열(Column)**로 표현합니다.
예를 들어, '고객' 엔티티의 속성은 '고객ID', '이름', '주소' 등의 열로 나타냅니다.

## 엔티티의 특징
업무에서 실제로 사용
엔티티는 현실 세계에서 의미가 있는 개체나 객체여야 하며, 실제로 업무나 시스템에서 사용되는 데이터를 대표합니다. 예를 들어, 고객, 주문, 제품 등의 엔티티는 실제로 업무에서 사용됩니다.

Unique Key가 있어야 함
엔티티는 **고유한 식별자(Unique Key)**를 가져야 합니다. 이는 해당 엔티티의 각 인스턴스를 유일하게 식별할 수 있는 속성입니다. 예를 들어, '고객ID'나 '주문ID'는 고유한 값을 가지며, 이를 통해 각 고객이나 주문을 식별할 수 있습니다.

2개 이상의 인스턴스를 갖고 있어야 함
엔티티는 최소 2개 이상의 인스턴스를 가질 수 있어야 합니다. 즉, 엔티티는 단 하나의 인스턴스만 있을 수 없으며, 여러 개의 데이터 항목(행)을 포함해야 합니다. 예를 들어, '고객' 엔티티는 여러 명의 고객을 나타낼 수 있어야 합니다. 만약 1개만 존재하거나, 앞으로도 1개만 존재할 것이라면 이는 엔티티가 아닙니다.

속성(Column)이 있어야 함
엔티티는 속성을 가지고 있어야 합니다. 속성은 엔티티의 특성이나 데이터를 나타내며, 테이블의 **열(Column)**로 표현됩니다. 예를 들어, '고객' 엔티티는 '고객ID', '이름', '주소', '전화번호' 등의 속성을 가질 수 있습니다.

다른 엔티티와 1개 이상의 관계를 갖고 있어야 함
엔티티는 다른 하나 이상의 엔티티와 관계를 가져야 합니다. 관계는 엔티티 간의 상호작용이나 연결을 나타내며, 이러한 관계는 데이터베이스 설계에서 중요한 요소입니다. 예를 들어, '고객' 엔티티는 '주문' 엔티티와 "주문한다"라는 관계를 가질 수 있습니다.

## 엔티티의 종류 - 유/무형에 따른 분류
1. 유형 엔티티 (Entity Type)
물리적 형태, 안정성, 지속성을 가진 엔티티입니다.
현실 세계에서 실제 존재하는 개체로, 물리적으로 존재하거나 지속적으로 관리되는 객체를 나타냅니다.
예:
회원: 실제로 존재하는 사람을 나타내는 엔티티입니다. 회원은 등록되고, 수정되며, 삭제될 수 있는 지속적인 존재입니다.
상품: 판매되는 상품, 재고로 관리되는 제품 등이 여기에 해당합니다. 상품은 실제로 존재하고 물리적인 형태를 가집니다.

3. 개념 엔티티 (Conceptual Entity)
물리적 형태는 없고, 개념적으로 존재하는 엔티티입니다.
물리적으로 존재하지 않지만, 특정 조직이나 시스템에서 이해하고 관리해야 할 개념을 나타냅니다.
예:
부서: 실제로 물리적으로 존재하지 않지만, 조직 내에서 중요한 개념입니다. 부서 간의 관계와 역할을 관리하는 데 사용됩니다.
학과: 대학이나 교육 기관에서 존재하는 개념으로, 학생들이 소속되는 학과를 나타냅니다.

3. 사건 엔티티 (Event Entity)
행위로 발생하는 엔티티입니다. 특정 활동이나 사건이 발생할 때 생성되는 엔티티입니다.
이 엔티티는 시간에 따라 변경되거나 종료될 수 있는 활동을 나타냅니다.
예:
주문: 고객이 제품을 주문하는 행위 자체를 나타내는 엔티티입니다. 주문은 특정 시점에 발생하며, 처리 후 종료됩니다.
이벤트 응모: 사용자가 특정 이벤트에 참여하는 행위로 생성되는 엔티티입니다. 응모는 이벤트가 종료되면 더 이상 존재하지 않을 수 있습니다.

정리
유형 엔티티는 물리적 존재와 지속적인 특성을 갖고 있습니다.
개념 엔티티는 물리적 존재는 없지만, 개념적으로 중요한 정보를 나타냅니다.
사건 엔티티는 특정 행위나 사건을 나타내며, 특정 시간에 발생하고 종료되는 특성을 가집니다.

## 엔티티의 종류 - 발생 시점에 따른 분류
1. 기본 엔티티 (Base Entity)
업무에 원래 존재하는 정보를 나타냅니다. 이 엔티티는 업무나 시스템에서 필수적인 데이터를 대표하며, 변화가 적고 안정적인 정보를 나타냅니다.
특징: 데이터가 자주 변하지 않으며, 대부분 시스템에 처음부터 존재하는 엔티티입니다.
예:
상품: 판매되는 제품에 대한 정보.
회원: 고객이나 사용자에 대한 정보.
사원: 회사에서 일하는 사람에 대한 정보.
부서: 조직 내 부서에 대한 정보.

2. 중심 엔티티 (Core Entity)
기본 엔티티로부터 파생된 엔티티로, 행위 엔티티를 생성하는 데 사용됩니다. 중심 엔티티는 기본 엔티티를 바탕으로 중요한 비즈니스 행위나 데이터를 표현하는 엔티티입니다.
특징: 특정 비즈니스 활동이나 사건을 추적하는 데 사용되며, 실제 업무 흐름과 관련된 중요한 엔티티입니다.
예:
주문: 상품이나 서비스를 구매하는 행위로 생성되는 엔티티.
매출: 상품 판매로 인해 발생하는 금전적 거래 내역.
계약: 서비스나 제품 제공을 위한 계약 정보를 나타내는 엔티티.

3. 행위 엔티티 (Action Entity)
2개 이상의 엔티티로부터 파생된 엔티티로, 특정 행위나 활동에 대한 기록을 나타냅니다. 이 엔티티는 데이터가 자주 변경되거나 증가할 수 있는 특성을 가집니다.
특징: 특정 시점에 발생한 행위나 이벤트의 내역을 기록하며, 시간이 지남에 따라 자주 갱신될 수 있습니다.

예:
주문 내역: 고객이 여러 차례 주문한 내역을 추적하는 엔티티.
이벤트 응모 이력: 사용자가 이벤트에 응모한 기록을 나타내는 엔티티.
배송 내역: 주문이 배송되는 과정에 대한 정보.
정리
기본 엔티티는 업무의 기본 정보를 나타내며 안정적입니다.
중심 엔티티는 기본 엔티티로부터 파생되어 비즈니스 활동을 추적하는 데 사용됩니다.
행위 엔티티는 2개 이상의 엔티티에서 파생되며, 자주 변경되거나 증가할 수 있는 기록을 관리합니다.

# 03 속성(Attribute)
## 속성의 특징
1️⃣ 더 이상 쪼개지지 않는 단위
속성은 원자적(Atomic) 이어야 하며, 더 이상 나눌 수 없는 최소 단위여야 함.
예: "이름" 속성은 "성"과 "이름"으로 나눌 수 있지만, 원자성을 유지하려면 하나로 저장해야 함.

2️⃣ 프로세스에 필요한 데이터 항목
업무 프로세스에서 사용되지 않는 속성은 불필요함.
예: "직원의 혈액형"이 업무에 필요하지 않다면 삭제하는 것이 좋음.

3️⃣ 속성은 하나의 값만 가져야 함 (Atomicity)
하나의 속성에는 하나의 값만 저장해야 함.
❌ 잘못된 예: 전화번호 = "010-1234-5678, 02-123-4567"
✅ 올바른 예: 휴대폰번호 = "010-1234-5678", 집전화번호 = "02-123-4567"

4️⃣ 하나의 엔티티는 두 개 이상의 속성을 가져야 함
하나의 엔티티는 최소 2개 이상의 속성을 포함해야 함.
예: "고객" 엔티티는 "고객ID", "이름", "연락처" 등의 속성을 가짐.

5️⃣ 엔티티의 구체적이고 명확한 정보를 나타냄
속성은 엔티티의 특성을 구체적으로 표현해야 함.

예: "주문" 엔티티의 "주문일자"는 주문이 언제 이루어졌는지 명확하게 나타냄.

## 속성의 분류 - 특성에 따른 분류

1️⃣ 기본 속성 (Basic Attribute)
업무 프로세스에서 직접 정의됨
가장 많은 비중을 차지함
예시: 이름, 생년월일, 주소, 전화번호

2️⃣ 설계 속성 (Designed Attribute)
업무에는 존재하지 않지만, 설계 과정에서 필요하다고 판단하여 추가된 속성
예시: 학생의 고유 번호, 고객 식별 ID

3️⃣ 파생 속성 (Derived Attribute)
다른 속성 값을 계산하거나 가공하여 생성된 속성
주로 조회 성능을 높이기 위해 사용됨
예시:
재고량 = (입고량 - 출고량)
좋아요 수 = (사용자의 좋아요 클릭 수)
총 구매 금액 = (단가 × 구매 수량)

## 속성의 분류 - 구성 방식에 따른 분류
1️⃣ PK 속성 (Primary Key Attribute)
인스턴스를 유일하게 식별할 수 있는 속성
NULL 값을 가질 수 없음
중복될 수 없음
예시: 학생 테이블 → 학번(Student_ID), 회원 테이블 → 회원번호(User_ID)

2️⃣ FK 속성 (Foreign Key Attribute)
다른 엔티티와 관계를 맺기 위해 사용되는 속성
NULL 값을 가질 수 있음 (관계가 없을 수도 있기 때문)
다른 테이블의 PK를 참조
예시:
주문 테이블 → 회원번호(User_ID) (회원 테이블의 User_ID를 참조)
도서 대여 테이블 → 책 ID(Book_ID) (도서 테이블의 Book_ID를 참조)

3️⃣ 일반 속성 (General Attribute)
PK와 FK를 제외한 나머지 속성
엔티티의 일반적인 정보를 저장
예시:
회원 테이블 → 이름(Name), 주소(Address), 전화번호(Phone_Number)
상품 테이블 → 상품명(Product_Name), 가격(Price), 재고(Stock)

## 도메인(Domain)
1️⃣ 도메인(Domain)
속성이 가질 수 있는 값의 범위
데이터의 유효성을 보장하기 위해 사용됨
예시:
우편번호 → 5자리 숫자 (00000~99999)
성별 → ‘M’(남자), ‘F’(여자)
나이 → 1~120

2️⃣ 용어 사전 (Business Glossary)
업무에서 사용하는 용어와 규칙을 정의
데이터 일관성을 유지하기 위해 업무 규칙(Rule) 설정
예시:
고객 등급: VIP(1000점 이상), 일반(1000점 미만)
주문 상태: ‘결제 완료’, ‘배송 중’, ‘배송 완료’

3️⃣ 시스템 카탈로그 (System Catalog)
DBMS 내부에서 시스템 정보를 저장하는 특수한 DB
여기에 저장된 데이터는 메타데이터(Metadata)
SELECT만 가능 (수정·삭제 불가)
예시:
테이블 정보 조회: SELECT * FROM INFORMATION_SCHEMA.TABLES;
컬럼 정보 조회: SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'users';
📌 도메인 관리를 통해 데이터 무결성을 보장하고, 시스템 카탈로그를 활용하여 DB 구조를 분석할 수 있음!

# 04 관계(Relationship)
## 관계의 종류
1️⃣ 존재 관계 (Existence Relationship)
존재 자체만으로 연관이 있는 관계
하나의 엔티티가 존재하려면 반드시 다른 엔티티가 필요함
예시:
엄마 - 아기 (아기는 엄마 없이 존재할 수 없음)
직원 - 부서 (직원은 반드시 부서에 소속됨)
학생 - 학과 (학생은 특정 학과에 속해야 함)

2️⃣ 행위 관계 (Action Relationship)
행위를 수행함으로써 생기는 관계
특정 이벤트나 동작이 수행될 때 엔티티 간의 연결이 형성됨
예시:
회원 - 주문 (회원이 주문을 하면 관계가 형성됨)
학생 - 출석 (학생이 수업에 출석할 때 관계가 생성됨)
고객 - 예약 (고객이 예약을 하면 관계가 만들어짐)

📌 존재 관계는 구조적인 연관성이 강하고, 행위 관계는 이벤트 기반으로 동적으로 형성됨!

## 관계 표기법
1️⃣ 관계명 (Relationship Name)
엔티티 간의 관계를 나타내는 문장
항상 양쪽에서 하나씩 두 개의 관계명 사용
명확한 의미를 가지며 현재형으로 작성
예시:
"고객 → 주문" → "고객은 주문을 한다", "주문 → 고객" → "주문은 고객에 의해 생성된다"
"학생 → 수강신청" → "학생은 수강 신청을 한다", "수강신청 → 학생" → "수강 신청은 학생에 의해 이루어진다"

2️⃣ 관계 차수 (Cardinality)
관계에 참여하는 엔티티의 수를 나타냄
종류:
1:1 (일대일) → 한 엔티티가 다른 엔티티의 하나와만 연결됨
예: 사원 - 사원증 (각 사원은 하나의 사원증만 가짐)
1:M (일대다) → 한 엔티티가 여러 개의 다른 엔티티와 연결됨
예: 회원 - 주문 (회원 한 명이 여러 개의 주문을 할 수 있음)
M:N (다대다) → 여러 개의 엔티티가 서로 여러 개의 다른 엔티티와 연결됨
예: 학생 - 강의 (학생은 여러 개의 강의를 들을 수 있고, 한 강의에는 여러 명의 학생이 참여할 수 있음)

3️⃣ 관계 선택 사양 (Optionality)
관계가 필수인지 선택인지 나타냄
필수 관계 (Mandatory Relationship) → 반드시 관계가 있어야 함
예: 학생 - 학과 (모든 학생은 반드시 하나의 학과에 소속됨)
선택 관계 (Optional Relationship) → 관계가 있을 수도 있고, 없을 수도 있음
예: 회원 - 주문 (회원이 반드시 주문을 해야 하는 것은 아님)

📌 정확한 관계명을 설정하고, 관계 차수와 선택 사양을 고려하여 데이터베이스의 무결성을 유지해야 함!
![image](https://github.com/user-attachments/assets/3797936e-9df4-4745-a6a8-fb2045abe7b7)
관계명/관계 차수
![image](https://github.com/user-attachments/assets/0ffbc0fb-cee4-46ea-ab9c-920458769a35)
관계 선택 사양

# 05 식별자(identifiers)
✅ **주 식별자(PK, Primary Key)의 특징 및 분류**  

---

### **📌 주 식별자(PK)란?**  
- **각 인스턴스를 유일하게 식별**하는 속성  
- **데이터베이스에서 Primary Key(PK)로 설정**  
- **유일성(Unique), 최소성(Minimality), 불변성(Immutability), 존재성(Non-null)을 만족해야 함**  

---

### **📌 주 식별자의 속성**  

1️⃣ **유일성(Unique)** → 각 인스턴스를 **서로 구별 가능**해야 함  
2️⃣ **최소성(Minimality)** → 불필요한 속성을 포함하지 않고 **최소한의 속성으로 구성**  
3️⃣ **불변성(Immutability)** → 한 번 부여되면 **변경되지 않아야 함**  
4️⃣ **존재성(Non-null)** → 반드시 값이 존재해야 하며 **NULL이 될 수 없음**  

---

### **📌 식별자의 분류**  

#### **1. 대표성 여부에 따른 분류**  
- **주 식별자(Primary Identifier, PK)**  
  - 대표적인 식별자로 **유일성, 최소성, 불변성, 존재성을 만족**  
  - 다른 엔티티와 **참조 관계(FK)로 연결 가능**  
  - **예시:** 학생(학번), 주문(주문번호)  

- **보조 식별자(Alternate Identifier, AK)**  
  - 유일하지만, 참조 관계에는 사용되지 않는 보조 식별자  
  - **예시:** 회원(회원ID → PK, 이메일 → 보조 식별자)  

#### **2. 생성 방식에 따른 분류**  
- **내부 식별자(Internal Identifier)**  
  - 엔티티 내부에서 **자체적으로 생성된 식별자**  
  - **예시:** 직원(사원번호), 고객(고객번호)  

- **외부 식별자(External Identifier, FK)**  
  - 다른 엔티티의 식별자를 **참조하는 식별자**  
  - **예시:** 주문(고객ID → 고객 엔티티의 PK를 참조하는 FK)  

#### **3. 단일 속성 여부에 따른 분류**  
- **단일 식별자(Simple Identifier)** → 하나의 속성으로 이루어진 식별자  
  - **예시:** 학생(학번), 도서(도서ID)  

- **복합 식별자(Composite Identifier)** → 두 개 이상의 속성으로 구성된 식별자  
  - **예시:** 수강신청(학번 + 과목코드)  

#### **4. 대체 여부에 따른 분류**  
- **원조 식별자(Natural Identifier)**  
  - 원래 업무에 존재하는 **가공되지 않은 원래의 식별자**  
  - **예시:** 주민등록번호, 차량번호  

- **대리 식별자(Surrogate Identifier)**  
  - 두 개 이상의 속성을 묶어 새로운 식별자를 만든 경우  
  - **예시:** 수강신청(학번 + 과목코드 대신 "수강번호" 추가)  

---

### **📌 식별자 vs 비식별자 관계**  

| 구분 | 식별자 관계 | 비식별자 관계 |
|------|-----------|-------------|
| **PK 존재 여부** | 자식 엔티티에 PK 없음 (부모 PK가 PK 역할) | 자식 엔티티가 자체 PK 가짐 |
| **부모 의존성** | 부모 엔티티가 있어야 자식 엔티티 생성 가능 | 부모 엔티티 없이도 자식 엔티티 생성 가능 |
| **삭제 영향** | 부모 삭제 시 자식도 삭제됨 (강한 결합) | 부모 삭제해도 자식 유지 가능 (느슨한 결합) |
| **예시** | 주문 - 주문 상세, 학생 - 성적 | 회원 - 주문, 직원 - 프로젝트 |

---

📌 **식별자는 데이터의 유일성을 보장하고, 데이터 참조 무결성을 유지하는 핵심 개념임!**




