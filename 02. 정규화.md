
다음과 같이 정리됨:

---

### 🔹 **정규화(Normalization)란?**  
- **정의**: 데이터 정합성(정확성, 일관성)을 위해 테이블을 작은 단위로 분리하는 과정  

---

### 🔹 **장점**
- 이상 현상(삽입/삭제/갱신 이상) 제거 및 방지  
- 구조 확장 시 재설계 최소화  
- 데이터 입력/수정/삭제 시 성능 향상  

---

### 🔹 **단점**
- Join 연산 증가로 인한 **조회 성능 저하 가능**  
  ↳ *단, 중복 제거로 조회 성능이 향상될 수도 있음*  
- 상황에 따라 **반정규화(Denormalization)** 수행 필요  

---

### 🔹 **이상 현상(Anomalies) 종류**
- **삽입 이상**: 일부 속성값이 없어 Null 입력해야 하는 상황  
- **삭제 이상**: 데이터 삭제 시 관련 정보까지 함께 삭제  
- **갱신 이상**: 중복된 데이터의 일부만 수정돼 데이터 불일치 발생  

---

✅ **결론**:  
무조건적인 정규화는 성능 저하를 초래할 수 있으며, 상황에 따라 정규화와 반정규화를 적절히 조합해야 함.

좋아, 완전 기초부터 차근차근 예시와 함께 하나씩 아주 쉽게 설명해줄게. 먼저 **정규화 전체 흐름 개요**부터 잡고, 그다음에 **각 정규형(1NF ~ 5NF, BCNF)**을 하나씩 예시로 나눠서 설명할게.

---

## ⭐️ 정규화란?

> **정규화(Normalization)** = **데이터 중복 제거 + 데이터 이상현상 방지**를 위해 **큰 테이블을 여러 개로 나누는 것**

📦 큰 테이블에 여러 데이터가 섞여 있으면 문제가 생겨. 예를 들면:

- 한 칸에 여러 값을 넣는다거나 (예: 취미 = "독서, 축구, 영화")
- 수정하려면 여러 행을 수정해야 한다거나
- 삭제하면 의도치 않게 다른 정보까지 날아간다거나

이런 걸 막기 위해 정규화를 하는 거야.

---

# 🔶 제1 정규화 (1NF)

> ✅ **모든 칸에는 하나의 값만 들어야 한다**  
> 즉, **"한 셀에 여러 값 X"**, **"비슷한 항목을 여러 칼럼에 나눠 넣기 X"**

### ✅ 예시 (정규화 전)

| 회원ID | 이름   | 취미              |
|--------|--------|-------------------|
| 101    | 철수   | 독서,축구         |
| 102    | 영희   | 영화,음악,등산     |

- 취미가 한 셀에 여러 개 들어있지?
- 이건 **원자값이 아님 → 1NF 위반**

### 🔧 정규화 후 (1NF 적용)

| 회원ID | 이름   | 취미   |
|--------|--------|--------|
| 101    | 철수   | 독서   |
| 101    | 철수   | 축구   |
| 102    | 영희   | 영화   |
| 102    | 영희   | 음악   |
| 102    | 영희   | 등산   |

➡️ 각 셀에는 **딱 하나의 값만** 존재함 → 1NF 만족!

---

# 🔶 제2 정규화 (2NF)

> ✅ **기본키의 '일부'에만 종속된 컬럼 제거**  
> 즉, **부분 함수 종속성 제거**

---

### ✅ 개념
- 기본키가 **두 개 이상(복합키)**일 때
- 어떤 일반 속성이 그 중 **일부 키에만 의존**하면 문제가 됨

---

### ✅ 예시 (정규화 전)

| 주문번호 | 상품코드 | 주문수량 | 상품명   |
|----------|----------|----------|----------|
| 001      | A100     | 2        | 키보드   |
| 001      | A200     | 1        | 마우스   |

- 기본키 = (주문번호, 상품코드)
- 주문수량은 전체 키(주문번호 + 상품코드)에 종속됨 → OK
- 하지만 상품명은 **상품코드만 있으면** 알 수 있어 → **부분 함수 종속**

---

### 🔧 정규화 후 (2NF 적용)

#### 📄 주문 테이블
| 주문번호 | 상품코드 | 주문수량 |
|----------|----------|----------|
| 001      | A100     | 2        |
| 001      | A200     | 1        |

#### 📄 상품 테이블
| 상품코드 | 상품명   |
|----------|----------|
| A100     | 키보드   |
| A200     | 마우스   |

➡️ 부분 종속 속성(상품명)을 분리함 → 2NF 만족!

---

# 🔶 제3 정규화 (3NF)

> ✅ **기본키를 제외한 컬럼들끼리의 종속 관계 제거**  
> 즉, **이행 함수 종속성 제거**

---

### ✅ 개념  
- 기본키 → A → B 형태
- 즉, **기본키가 직접적으로 아닌 다른 일반 속성을 통해 또 다른 일반 속성을 알 수 있다면** → 이행 종속

---

### ✅ 예시 (정규화 전)

| 연예인ID | 연예인명 | 소속사코드 | 소속사명     |
|----------|----------|-------------|--------------|
| A01      | 아이유   | C100        | 이담엔터     |
| A02      | 유재석   | C200        | 안테나       |

- 기본키: 연예인ID
- 소속사코드는 연예인ID로부터 알 수 있음
- 소속사명은 소속사코드로부터 알 수 있음
- 그러면 **연예인ID → 소속사코드 → 소속사명**  
  즉, **연예인ID → 소속사명** → 이행 함수 종속

---

### 🔧 정규화 후 (3NF 적용)

#### 📄 연예인 테이블
| 연예인ID | 연예인명 | 소속사코드 |
|----------|----------|-------------|
| A01      | 아이유   | C100        |

#### 📄 소속사 테이블
| 소속사코드 | 소속사명     |
|-------------|--------------|
| C100        | 이담엔터     |

➡️ 일반 속성 간 종속 제거 → 3NF 만족!

---

여기까지가 **실무에서 가장 자주 사용되는 1NF ~ 3NF**야.  
다음은 조금 더 고급 정규화인 **BCNF, 4NF, 5NF**인데, 이것도 이어서 아주 쉽게 설명해줄게.

계속할까?

좋아! 지금까지 했던 **1NF ~ 3NF**에 이어서, **BCNF, 4NF, 5NF**까지 포함해서 전체 정규화 과정을 아주 쉽게, 예시 중심으로 정리해줄게.

---

# ✅ 전체 정규형 요약표 (한 줄 개념 정리)

| 정규형     | 핵심 개념                             | 목적                          |
|------------|----------------------------------------|-------------------------------|
| **1NF**    | 칼럼에 **하나의 값만** (원자값)         | 중복 제거, 반복 속성 제거       |
| **2NF**    | **부분 종속 제거** (복합키일 때)         | 모든 컬럼이 전체 키에 종속      |
| **3NF**    | **이행 종속 제거** (속성 간 종속 제거)   | 일반 속성 간 종속 제거          |
| **BCNF**   | 모든 결정자가 **후보키**일 것             | 이상 현상 제거 (더 강한 3NF)    |
| **4NF**    | **다치 종속 제거** (1:N 관계가 중복됨)   | 독립된 1:N 관계는 분리           |
| **5NF**    | **조인 종속 제거** (분해한 걸 다시 조인할 때만 정확) | 복잡한 조인 오류 방지          |

---

# 🔶 Boyce-Codd 정규형 (BCNF)

> ✅ **결정자가 반드시 후보키여야 함**

---

### ✅ 예시 (정규화 전)

| 강의실 | 과목   | 교수     |
|--------|--------|----------|
| 101    | 수학   | 김교수   |
| 101    | 과학   | 김교수   |

- 규칙:  
  - 강의실 + 과목 → 교수 ✅  
  - 교수 → 강의실 ❌ 후보키가 아님

즉, 교수 → 강의실은 **후보키가 아닌 결정자** → **BCNF 위반**

---

### 🔧 정규화 후 (BCNF 적용)

#### 📄 강의 배정
| 과목 | 교수   |
|------|--------|
| 수학 | 김교수 |
| 과학 | 김교수 |

#### 📄 교수별 강의실
| 교수   | 강의실 |
|--------|--------|
| 김교수 | 101    |

➡️ 모든 결정자가 후보키 → BCNF 만족

---

# 🔶 제4 정규형 (4NF)

> ✅ **다치 종속 제거**  
> 즉, **하나의 주제에 여러 개의 1:N 관계가 서로 독립적으로 존재할 때 분리**

---

### ✅ 예시 (정규화 전)

| 학생 | 악기   | 외국어   |
|------|--------|----------|
| 철수 | 피아노 | 영어     |
| 철수 | 피아노 | 일본어   |
| 철수 | 기타   | 영어     |
| 철수 | 기타   | 일본어   |

- 철수는 피아노, 기타를 배우고 있고
- 영어, 일본어를 따로 배우는 중
- 그런데 **악기와 외국어는 서로 관계 없음** → **다치 종속**

---

### 🔧 정규화 후 (4NF 적용)

#### 📄 악기 테이블
| 학생 | 악기   |
|------|--------|
| 철수 | 피아노 |
| 철수 | 기타   |

#### 📄 외국어 테이블
| 학생 | 외국어 |
|------|--------|
| 철수 | 영어   |
| 철수 | 일본어 |

➡️ 독립된 1:N 관계는 분리 → 4NF 만족

---

# 🔶 제5 정규형 (5NF)

> ✅ **조인 종속 제거**  
> 즉, **분해된 테이블을 조인했을 때만 완전해지는 경우 → 이를 분리**

---

### ✅ 예시 (정규화 전)

| 제품 | 부품 | 공급자 |
|------|------|--------|
| A    | X    | P      |
| A    | Y    | P      |
| A    | X    | Q      |
| A    | Y    | Q      |

- 제품 A는 부품 X, Y로 구성
- P, Q는 모두 부품 X, Y를 공급 가능
- 따라서 총 4개의 조합이 생기지만  
  이건 **부품 ↔ 공급자**, **제품 ↔ 부품**, **제품 ↔ 공급자**  
  → 이런 3개 관계의 **조합으로만 전체가 구성됨**

---

### 🔧 정규화 후 (5NF 적용)

#### 📄 제품-부품
| 제품 | 부품 |
|------|------|
| A    | X    |
| A    | Y    |

#### 📄 부품-공급자
| 부품 | 공급자 |
|------|--------|
| X    | P      |
| X    | Q      |
| Y    | P      |
| Y    | Q      |

#### 📄 제품-공급자
| 제품 | 공급자 |
|------|--------|
| A    | P      |
| A    | Q      |

➡️ 세 개 테이블로 나누고, 다시 조인했을 때 정확히 원래 테이블 나옴 → 5NF 만족

---

## ✅ 정리 요약

| 정규형 | 의미 요약                           | 핵심 조건                              |
|--------|--------------------------------------|-----------------------------------------|
| 1NF    | 셀에 값이 하나여야 한다             | 반복 컬럼 제거, 원자값 유지             |
| 2NF    | 부분 종속 제거 (복합키 대상)        | 기본키 전체에 종속되어야 함             |
| 3NF    | 이행 종속 제거                      | 기본키 아닌 컬럼 간 종속 제거           |
| BCNF   | 결정자가 후보키여야 함              | 더 강한 3NF                              |
| 4NF    | 다치 종속 제거                      | 독립된 N:N 관계 분리                    |
| 5NF    | 조인 종속 제거                      | 완전한 관계 복원을 위한 조인만 허용     |

---

필요하다면 각 정규형에 대해 **다른 예시나 연습문제**도 만들어줄 수 있어.  
더 설명해줄 부분 있을까?

좋아, 지금부터 **SQLD 시험**의 **"관계형 데이터 모델과 무결성"** 파트 중  
**[관계형 데이터베이스 개요]**에 대해 **공식 출제 기준 기반**으로 아주 상세하고 쉽게 정리해줄게.

---

## ✅ 관계형 데이터베이스 개요: 전체 개관

**관계형 데이터베이스(Relational Database)**란?

- 데이터를 **행(Row)**과 **열(Column)**로 구성된 **테이블(Table)**에 저장하는 방식
- **수학의 관계(Relation)** 이론에 기반함
- **1970년 IBM의 에드가 F. 코드(Edgar F. Codd)** 박사가 제안함

---

### ✅ 1. 관계형 데이터베이스의 3가지 구조

| 구분         | 설명 |
|--------------|------|
| **논리적 구조** | 릴레이션(테이블), 애트리뷰트(속성), 투플(행) 등의 논리적 요소로 구성 |
| **물리적 구조** | 데이터를 실제 저장소(디스크)에 저장하는 방식 |
| **뷰(View)**     | 하나 이상의 테이블에서 파생된 가상의 테이블 (SQL로 정의됨) |

---

### ✅ 2. 주요 용어 정의

| 용어         | 설명 |
|--------------|------|
| **릴레이션 (Relation)** | 테이블 (논리적인 데이터 구조) |
| **애트리뷰트 (Attribute)** | 컬럼(Column) — 하나의 속성 (예: 이름, 나이) |
| **도메인 (Domain)** | 컬럼이 가질 수 있는 값의 범위 |
| **튜플 (Tuple)** | 하나의 행(Row) — 하나의 레코드 |
| **카디널리티 (Cardinality)** | 릴레이션에 있는 튜플의 개수 (행 개수) |
| **차수 (Degree)** | 릴레이션에 있는 애트리뷰트의 개수 (열 개수) |

---

### ✅ 3. 릴레이션의 특징 (관계형 테이블의 성질)

| 특징 | 설명 |
|------|------|
| **튜플의 순서 없음** | 행의 순서가 데이터 의미에 영향 없음 |
| **속성의 순서 없음** | 열의 순서도 의미 없음 |
| **튜플의 유일성**   | 중복된 행(레코드) 허용 안 됨 |
| **원자값만 허용**   | 셀 하나에는 **하나의 값만** 있어야 함 (1NF와 관련됨) |
| **속성명 유일**     | 속성 이름은 릴레이션 내에서 고유해야 함 |

---

### ✅ 4. 키(Key)의 개념

관계형 모델에서 데이터를 **식별하고 무결성 유지**를 위한 핵심 요소

| 키 종류 | 설명 |
|---------|------|
| **슈퍼키**     | 유일하게 튜플을 식별할 수 있는 속성 집합 |
| **후보키**     | 슈퍼키 중에서 **최소 조건을 만족**하는 키 (중복 제거) |
| **기본키(PK)** | 후보키 중 **대표로 선택된 키**, NULL 불가, 중복 불가 |
| **대체키**     | 기본키로 선택되지 않은 나머지 후보키 |
| **외래키(FK)** | 다른 테이블의 기본키를 참조하는 키 |

---

### ✅ 5. 무결성 제약조건 (Integrity Constraints)

데이터의 **정확성, 일관성**을 보장하기 위한 규칙들

| 무결성 종류     | 설명 |
|----------------|------|
| **개체 무결성**   | 기본키는 **NULL, 중복 허용 안됨** |
| **도메인 무결성** | 속성값은 **정의된 도메인 범위** 내 값이어야 함 |
| **참조 무결성**   | 외래키는 **기본키를 참조하거나 NULL이어야** 함 |
| **사용자 정의 무결성** | 비즈니스 규칙 기반 사용자 정의 제약 (예: 수량은 0 이상 등) |

---

### ✅ 6. 관계형 데이터베이스의 장점

| 장점 항목 | 설명 |
|-----------|------|
| **데이터 독립성** | 논리 구조와 물리 구조를 분리하여 관리 |
| **무결성 유지** | 키, 제약조건 등으로 정확한 데이터 유지 |
| **동시성 제어** | 여러 사용자도 동시에 접근 가능 (트랜잭션 관리) |
| **보안성**     | 사용자별 접근 권한 설정 가능 |
| **데이터 중복 최소화** | 정규화 과정을 통해 데이터 중복 제거 |

---

### ✅ 7. 관계형 모델 vs 계층/망형 모델 비교

| 항목           | 관계형 모델         | 계층형 / 망형 모델     |
|----------------|---------------------|-------------------------|
| 구조           | 테이블(릴레이션) 기반 | 트리 / 그래프 구조       |
| 복잡성         | 단순함               | 복잡한 구조             |
| 질의 방식       | SQL로 직관적 질의 가능 | 프로그래밍적으로 질의      |
| 데이터 독립성   | 높음                | 낮음                    |
| 중복/무결성 관리 | 우수                | 취약                    |

---

## 📝 요약 암기 키워드

- 릴레이션 = 테이블  
- 속성(Attribute) = 열(Column)  
- 투플(Tuple) = 행(Row)  
- 도메인 = 값의 범위  
- 키: 슈퍼키 > 후보키 > 기본키/대체키 > 외래키  
- 무결성: 개체 / 도메인 / 참조 / 사용자정의  
- 릴레이션 특징: 순서X, 중복X, 원자값만  
- 1NF ~ 5NF = 정규화 원칙 (중복 제거 및 이상 방지)

---

원하면 위 내용을 PDF나 요약 노트로도 정리해줄 수 있어.  
다음으로 이어서 **무결성 제약조건, 키, 정규화 예제 문제** 등 더 보고 싶어?

좋아, 이번에는 SQLD “관계형 데이터 모델과 무결성” 파트의 **세 번째 핵심 주제**인  
바로 **키(Key)**에 대해 아주 상세하게 정리해줄게.

---

## ✅ 키 (Key)의 개념과 종류

---

### ✅ 1. 키(Key)란?

> 릴레이션(테이블)에서 **튜플(행)을 유일하게 식별**하기 위한 속성 또는 속성들의 집합  
> 즉, **중복 없는 레코드 구분자**

---

## 🔑 키의 종류 (6가지)

| 키 종류           | 설명 요약 |
|------------------|-----------|
| 후보키 (Candidate Key) | 유일성과 최소성을 만족하는 속성 집합 |
| 기본키 (Primary Key)   | 후보키 중 대표로 선택된 키 |
| 대체키 (Alternate Key) | 기본키로 선택되지 않은 나머지 후보키 |
| 슈퍼키 (Super Key)     | 유일성만 만족하는 속성 집합 |
| 외래키 (Foreign Key)   | 다른 테이블의 기본키를 참조하는 키 |
| 복합키 (Composite Key) | 두 개 이상의 컬럼으로 구성된 키 |

---

## 🔍 각 키 자세히 설명

### ✅ 1. 후보키 (Candidate Key)

- 테이블에서 **유일하게 한 튜플을 식별**할 수 있는 속성들의 집합
- 유일성 + 최소성 만족

✔️ 유일성: 중복 없음  
✔️ 최소성: 구성 속성 중 **하나라도 빠지면 유일성 깨짐**

📌 예시:
```text
학생 테이블: (학번, 주민등록번호, 이메일)
→ 세 개 모두 유일 → 후보키 3개
```

---

### ✅ 2. 기본키 (Primary Key)

- 후보키 중 **대표로 선택된 하나**
- 반드시 **NOT NULL**, **UNIQUE**
- 테이블 당 **하나만 설정 가능**

📌 예시:
```sql
CREATE TABLE Student (
  student_id INT PRIMARY KEY,
  ssn CHAR(13) UNIQUE
);
```
→ `student_id`가 기본키, `ssn`은 대체키

---

### ✅ 3. 대체키 (Alternate Key)

- **후보키 중 기본키로 선택되지 않은 나머지 키**

📌 예시:
- 학번(student_id): 기본키  
- 주민등록번호(ssn): 대체키

---

### ✅ 4. 슈퍼키 (Super Key)

- **유일성은 만족하나 최소성은 만족하지 않음**

📌 예시:
- (학번), (학번+이름), (주민번호), (주민번호+전화번호) 등

→ (학번+이름)은 학번만으로 유일하므로 **최소성 위배 → 슈퍼키**

---

### ✅ 5. 외래키 (Foreign Key)

- **다른 릴레이션의 기본키를 참조**하는 속성
- 참조 대상 테이블에 **해당 값이 존재해야 함**
- 참조 무결성을 유지

📌 예시:
```sql
CREATE TABLE Orders (
  order_id INT PRIMARY KEY,
  customer_id INT,
  FOREIGN KEY (customer_id) REFERENCES Customers(customer_id)
);
```

---

### ✅ 6. 복합키 (Composite Key)

- **2개 이상의 속성으로 구성된 키**
- 개별 속성만으로는 유일하지 않으나 **결합하면 유일성 확보**

📌 예시:
```text
수강 테이블: (학번, 과목코드)
→ 같은 학번은 여러 과목 수강 가능  
→ 같은 과목도 여러 명 수강 가능  
→ 하지만 (학번 + 과목코드) 조합은 유일
```

---

## ✅ 키 종류 요약 비교표

| 키 종류       | 유일성 | 최소성 | 중복 허용 | 설명 |
|--------------|--------|--------|------------|------|
| 슈퍼키       | ✔️     | ❌     | ❌         | 유일하지만 최소 아님 |
| 후보키       | ✔️     | ✔️     | ❌         | 유일하고 최소 |
| 기본키       | ✔️     | ✔️     | ❌         | 후보키 중 대표 |
| 대체키       | ✔️     | ✔️     | ❌         | 후보키 중 기본키 제외 |
| 외래키       | ❌     | ❌     | ✔️ 가능    | 다른 테이블 기본키 참조 |
| 복합키       | ✔️     | ✔️     | ❌         | 여러 속성 결합한 후보키 |

---

이제 다음으로는 관계형 모델에서 가장 중요한 **정규화(1NF ~ 5NF, BCNF)** 파트를 아주 상세하게 설명해줄 차례야.  
진행할까?
